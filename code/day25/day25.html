<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/305825 (zh-CN, DDL); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="1348"/>

<div>
<span><div>梳理知识点</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">原型 ：   可以复用  优先级低</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">原型链 ： Object  实例对象和原型之间的链接   通过 __proto__ 查找  </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">继承 ：   this.pre = Father    </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">         call  apply </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">         原型 ：  子类.prototype = new 父类()  </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">         混合继承  ：  </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">ES6构造函数 ： </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    class  类{</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">        constructor(name){</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">            this.name = name</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">        }</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">        方法(){  .. }</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    }</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    class 子类  extends 父类{</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">        </span><span style="font-size: 12pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">constructor(name){</span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">            super(...);</span></font></div><div><span style="font-size: 12pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    </span><span style="font-size: 12pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    </span><span style="font-size: 12pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    this.name = name</span></div><div><span style="font-size: 12pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    </span><span style="font-size: 12pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    </span><span style="font-size: 12pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">}</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    }</span></div></div><div><br/></div><div><span style="font-size: 16px;">1、什么是设计模式？</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。   设计模式就是一种 编程规范  架构层面的</span></div></div><div><br/></div><div><span style="font-size: 16px;">2、设计模式之单例模式</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">单例：对象只能实例化(创建)一次就叫单例 </span></div><div><br/></div><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">单例模式：字面量的对象声明{}，其实在设计模式中可以看作是一种单例模式，所谓</span><span style="font-size: 16px; background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 16px; color: rgb(255, 70, 53); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">单例模式，就是永远保持对象的一个实例</span></span><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">。</span></div><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">var  obj= new Object();</span></div><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">var obj = {};</span></div><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">obj = {}    一次只能创建一个对象  -    单例模式</span></div><div><br/></div><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     //实现单利模式</span></div><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     //  实现思路：  将第一次new出来的对象 this  保存到一个变量中 ，返回这个变量</span></div><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     //再次创建对象时，判断  这个变量中是否含有值，如果有值，就直接将这个变量返回</span></div><div><br/></div><div><span style="background-color: rgb(251, 250, 248); font-size: 16px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">      </span><span style="min-height: 18pt; font-size: 16pt; background-color: rgb(251, 250, 248); color: rgb(54, 75, 192); font-family: consolas;">function</span> <span style="min-height: 18pt; font-size: 16pt; background-color: rgb(251, 250, 248); color: rgb(219, 120, 0); font-family: consolas;">Animal</span><span style="min-height: 18pt; font-size: 16pt; background-color: rgb(251, 250, 248); color: rgb(8, 8, 8); font-family: consolas;">(){</span></div><div style="min-height: 18pt;"><span style="min-height: 18pt; font-size: 16pt; background-color: rgb(251, 250, 248); color: rgb(8, 8, 8); font-family: consolas;">        </span><span style="min-height: 18pt; font-size: 16pt; background-color: rgb(251, 250, 248); color: rgb(149, 163, 171); font-family: consolas;">//为了防止全局变量的污染  使用私有变量代替 全局变量 ins</span></div><div style="min-height: 18pt;"><span style="min-height: 18pt; font-size: 16pt; background-color: rgb(251, 250, 248); color: rgb(1, 1, 1); font-family: consolas;">        </span><span style="min-height: 18pt; font-size: 16pt; background-color: rgb(251, 250, 248); color: rgb(149, 163, 171); font-family: consolas;">//在构造函数的内部 可以通过    构造函数名.变量      创建一个私有变量    </span></div><div style="min-height: 18pt;"><span style="min-height: 18pt; font-size: 16pt; background-color: rgb(251, 250, 248); color: rgb(62, 75, 83); font-family: consolas;">   </span><span style="min-height: 18pt; font-size: 16pt; background-color: rgb(251, 250, 248); color: rgb(1, 1, 1); font-family: consolas;">    </span> <span style="min-height: 18pt; font-size: 16pt; background-color: rgb(251, 250, 248); color: rgb(87, 121, 9); font-family: consolas;">if</span><span style="min-height: 18pt; font-size: 16pt; background-color: rgb(251, 250, 248); color: rgb(8, 8, 8); font-family: consolas;">(Animal.ins){</span></div><div style="min-height: 18pt;"><span style="min-height: 18pt; font-size: 16pt; background-color: rgb(251, 250, 248); color: rgb(8, 8, 8); font-family: consolas;">           </span> <span style="min-height: 18pt; font-size: 16pt; background-color: rgb(251, 250, 248); color: rgb(87, 121, 9); font-family: consolas;">return</span> <span style="min-height: 18pt; font-size: 16pt; background-color: rgb(251, 250, 248); color: rgb(8, 8, 8); font-family: consolas;">Animal.ins;</span></div><div style="min-height: 18pt;"><span style="min-height: 18pt; font-size: 16pt; background-color: rgb(251, 250, 248); color: rgb(8, 8, 8); font-family: consolas;">        }</span></div><div style="min-height: 18pt;"><span style="min-height: 18pt; font-size: 16pt; background-color: rgb(251, 250, 248); color: rgb(8, 8, 8); font-family: consolas;">        Animal.ins</span> <span style="min-height: 18pt; font-size: 16pt; background-color: rgb(251, 250, 248); color: rgb(87, 121, 9); font-family: consolas;">=</span> <span style="min-height: 18pt; font-size: 16pt; background-color: rgb(251, 250, 248); color: rgb(54, 75, 192); font-family: consolas;">this</span></div><div style="min-height: 18pt;"><span style="min-height: 18pt; font-size: 16pt; background-color: rgb(251, 250, 248); color: rgb(54, 75, 192); font-family: consolas;">       </span> <span style="min-height: 18pt; font-size: 16pt; background-color: rgb(251, 250, 248); color: rgb(87, 121, 9); font-family: consolas;">return</span> <span style="min-height: 18pt; font-size: 16pt; background-color: rgb(251, 250, 248); color: rgb(8, 8, 8); font-family: consolas;">Animal.ins;</span></div><div><span style="min-height: 18pt; font-size: 16pt; background-color: rgb(251, 250, 248); color: rgb(8, 8, 8); font-family: consolas;">    }</span></div><div><br/></div><div><span style="min-height: 18pt; font-size: 16pt; background-color: rgb(251, 250, 248); color: rgb(8, 8, 8); font-family: consolas;">    单例模式上的属性可以全局使用</span></div></div><div><br/></div><div><span style="font-size: 16px;">3、设计模式之代理模式</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">代理模式: 为其他对象提供一种代理，并以控制对这个对象的访问。  </span></div><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">function A(){</span></div><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    this.dance = function(){</span></div><div><br/></div><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    }</span></div><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">}</span></div><div><br/></div><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">function B(){</span></div><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    this.aa = new A();</span></div><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    this.dance = function(){</span></div><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">        if(..){</span></div><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">            this.aa.dance(); //在B中实现A中的功能   这个过程就称作代理</span></div><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">        }</span></div><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    }</span></div><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">}</span></div><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"> </span></div></div><div><br/></div><div><span style="font-size: 16px;">4、设计模式之适配器模式</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。</span></div><div><br/></div><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</span></div><div><span style="background-color: rgb(251, 250, 248);">function A(){</span></div><div><span style="background-color: rgb(251, 250, 248);">}</span></div><div><span style="background-color: rgb(251, 250, 248);">fnuction B(){</span></div><div><br/></div><div><span style="background-color: rgb(251, 250, 248);">}</span></div><div><span style="background-color: rgb(251, 250, 248);">function Adaper(){  同时操作A类和B类的功能</span></div><div><br/></div><div><span style="background-color: rgb(251, 250, 248);">}</span></div></div><div><br/></div><div><span style="font-size: 16px;">5、设计模式之工厂模式</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">让对象的调用者和对象创建过程分离，当对象调用者需要对象时，直接向工厂请求即可。从而避免了对象的调用者与对象的实现类似编码方</span><span style="font-size: 16px; background-color: rgb(251, 250, 248); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">式耦合</span><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">，以提高系统的可维护性、可扩展性。</span></div></div><div><br/></div><div style="font-size: 13.3333px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑;">6、设计模式之观察者模式</span></div><div style="font-size: 13.3333px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div><br/></div></div><div style="letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">观察者模式又叫发布订阅模式（Publish/Subscribe），它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。</span></div><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">6:30  放学 ---- 等时间的过程  6:30  老师通知你放学</span></div><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">水壶烧水 ---- 听到叫声  水开了      </span></div><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">小孩哭了  ----  饿了  开始喂奶了</span></div></div><div style="font-size: 13.3333px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="font-size: 13.3333px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑;">7、策略模式</span></div><div style="font-size: 13.3333px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div><br/></div></div><div style="letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">定义一系列算法，把他们一个一个封装起来，并且使他们可以相互替换(具有相同的目标和意图)</span></div><div style="letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div><br/></div></div></div><div><br/></div><div>8、闭包</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">什么是闭包？</span></div><div><span style="font-size: 16px; background-color: rgb(255, 250, 232); color: rgb(149, 163, 171); font-family: Consolas;">一个函数返回一个匿名函数，这个匿名函数就称为闭包</span></div><div align="left" style="min-height: 18pt;"><div><span style="font-size: 16pt; background-color: rgb(255, 250, 232); color: rgb(149, 163, 171); font-family: Consolas;">能够访问其它函数内部局部变量的函数，这样的函数就称为闭包    闭包的形式多样 ，但都是局部函数全局执行</span></div><div><span style="font-size: 16pt; background-color: rgb(255, 250, 232); color: rgb(149, 163, 171); font-family: Consolas;">闭包作用 ： 通过闭包可以访问一个函数内部的局部变量</span></div><div><span style="font-size: 16pt; background-color: rgb(255, 250, 232); color: rgb(149, 163, 171); font-family: Consolas;">           可以让一个局部变量长期驻留在内存中  </span></div><div><span style="font-size: 16pt; background-color: rgb(255, 250, 232); color: rgb(149, 163, 171); font-family: Consolas;">闭包中的this 指向 window对象  </span></div></div></div><div><br/></div><div>9、xss攻击</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 12pt;">跨站脚本攻击  （cross  site  scripting）</font></div><div><font style="font-size: 12pt;">为了不和层叠样式表混淆  将跨站脚本攻击写成xss</font></div><div><font style="font-size: 12pt;">当用户在表单中输入一些具有特定含义的字符时，服务器端会识别这些特殊字符，这个过程就称为脚本攻击。</font></div><div><font style="font-size: 12pt;">解决脚本攻击 ： </font></div><div><font style="font-size: 12pt;"><span>    前端解决：  正则     会有bug   </span><br/></font></div><div><font style="font-size: 12pt;"><span>    根本解决 ： 通过服务器解决   ---  接收客户端提交的数据时，将数据进行过滤    </span></font></div><div><font style="font-size: 12pt;"><span>    </span></font></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 